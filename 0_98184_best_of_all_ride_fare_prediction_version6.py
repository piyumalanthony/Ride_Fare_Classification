# -*- coding: utf-8 -*-
"""0.98184_BEST_OF_ALL_Ride_Fare_Prediction_version6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hcpj-Bs69boIndzmqqJt7CORNqVS-pqy

# Importing Libraries
"""

from google.colab import drive
drive.mount('/content/drive')

cd /content/drive/My Drive/Machine learning

# Commented out IPython magic to ensure Python compatibility.
from pathlib import Path

import numpy as np
import pandas as pd
# %matplotlib inline
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.compose import ColumnTransformer

from sklearn.linear_model import LogisticRegression
from sklearn.multioutput import MultiOutputClassifier
import xgboost as xgb

from sklearn.pipeline import Pipeline
from sklearn.ensemble import RandomForestClassifier

from sklearn.model_selection import train_test_split

from sklearn.metrics import roc_curve, roc_auc_score

pd.set_option("display.max_columns", 100)

from sklearn.ensemble import AdaBoostClassifier
from sklearn.tree import DecisionTreeClassifier

from sklearn import preprocessing
min_max_scaler = preprocessing.MinMaxScaler()

!pip install catboost

from catboost import CatBoostClassifier,Pool

#methods for distance calculation
def distance(lat1, lon1, lat2, lon2):
    p = 0.017453292519943295 # Pi/180
    a = 0.5 - np.cos((lat2 - lat1) * p)/2 + np.cos(lat1 * p) * np.cos(lat2 * p) * (1 - np.cos((lon2 - lon1) * p)) / 2
    return 0.6213712 * 12742 * np.arcsin(np.sqrt(a))

features_df = pd.read_csv(
    "train.csv", 
    index_col="tripid"
)

"""# Preprocessing data"""

#removing noisy locations
features_df.drop( features_df[ features_df['pick_lat'] < 5.9 ].index , inplace=True)
features_df.drop( features_df[ features_df['pick_lat'] > 9.82 ].index , inplace=True)	
features_df.drop( features_df[ features_df['pick_lon'] < 79 ].index , inplace=True)
features_df.drop( features_df[ features_df['pick_lon'] > 82 ].index , inplace=True)
features_df.drop( features_df[ features_df['drop_lat'] < 5.9 ].index , inplace=True)
features_df.drop( features_df[ features_df['drop_lat'] > 9.82 ].index , inplace=True)	
features_df.drop( features_df[ features_df['drop_lon'] < 79 ].index , inplace=True)
features_df.drop( features_df[ features_df['drop_lon'] > 82 ].index , inplace=True)

#removing dupicates
features_df = features_df.drop_duplicates()

features_df

features_df["distance"] =  distance(features_df["pick_lat"],features_df["pick_lon"],features_df["drop_lat"],features_df["drop_lon"])

features_df["pickup_time"] = pd.to_datetime(features_df["pickup_time"],errors = "coerce")
features_df["drop_time"] = pd.to_datetime(features_df["drop_time"],errors = "coerce")
features_df['duration'] = features_df['duration'].fillna((features_df['drop_time'] - features_df['pickup_time']).astype('timedelta64[s]'))

"""# Nan Estimation"""

features_df['additional_fare'] = features_df['additional_fare'].fillna(features_df['additional_fare'].mode().iloc[0])

features_df_correct = features_df[features_df.label=='correct']
features_df_incorrect = features_df[features_df.label=='incorrect']

features_df_correct['meter_waiting'] = features_df_correct['meter_waiting'].fillna(features_df_correct['meter_waiting'].mean())
features_df_incorrect['meter_waiting'] = features_df_incorrect['meter_waiting'].fillna(features_df_incorrect['meter_waiting'].mean())

features_df_correct['meter_waiting_fare'] = features_df_correct['meter_waiting_fare'].fillna(features_df_correct['meter_waiting_fare'].mean())
features_df_incorrect['meter_waiting_fare'] = features_df_incorrect['meter_waiting_fare'].fillna(features_df_incorrect['meter_waiting_fare'].mean())

# fare nans replacement with considering class means
features_df_correct['fare'] = features_df_correct['fare'].fillna((92.33)*features_df_correct['distance']+features_df_correct['additional_fare']+features_df_correct['meter_waiting_fare'])
features_df_incorrect['fare'] = features_df_incorrect['fare'].fillna((221)*features_df_incorrect['distance']+features_df_incorrect['additional_fare']+features_df_incorrect['meter_waiting_fare'])

# features_df = pd.concat([features_df_correct,features_df_incorrect],sort=True)

# features_df.describe()

y= features_df["label"]

y =y.replace(to_replace="correct",value=1)
y =y.replace(to_replace="incorrect",value=0)

X = features_df.drop(columns=["label"], axis=1)

test_features_df = pd.read_csv("test.csv", 
                               index_col="tripid")

test_features_df

X

#X = X.dropna()

X

test_features_df = test_features_df.fillna(test_features_df.mean())

"""# Feature Generation"""

X["pickup_time"] = pd.to_datetime(X["pickup_time"],errors = "coerce")

X["drop_time"] = pd.to_datetime(X["drop_time"],errors = "coerce")

X["pickup_time_hour"] = X["pickup_time"].dt.hour

X["pickup_time_minute"] = X["pickup_time"].dt.minute

X["drop_time_hour"] =X["drop_time"].dt.hour

X["drop_time_minute"] =X["drop_time"].dt.minute

X["pickup_time_day"] = X["pickup_time"].dt.day
# X["pickup_time_month"] = X["pickup_time"].dt.month
X["drop_time_day"] = X["drop_time"].dt.day
# X["drop_time_month"] = X["drop_time"].dt.month
# X["pick_up_year"] = X["drop_time"].dt.year
# X["drop_year"] = X["drop_time"].dt.year

X.dtypes

X["effective_time"] = X["duration"]-X["meter_waiting"]

X.loc[X['fare'] <= 2000, 'fare_outlier'] = 1
X.loc[X['fare'] > 2000, 'fare_outlier'] = 0

X['meter_waiting_fare_diff'] = X['meter_waiting_fare'] - X['meter_waiting']*0.057

X['fare_mean'] = (X['fare'] - X['meter_waiting_fare'])/(X['duration'] - X['meter_waiting'])

# X.loc[X['additional_fare'] <= 100, 'additional_fare_outlier'] = 1
# X.loc[X['additional_fare'] > 100, 'additional_fare_outlier'] = 0

# X.loc[X['meter_waiting'] <= 2000, 'meter_waiting_outlier'] = 1
# X.loc[X['meter_waiting'] > 2000, 'meter_waiting_outlier'] = 0

# X.loc[X['duration'] <= 6000, 'duration_outlier'] = 1
# X.loc[X['duration'] > 6000, 'duration_outlier'] = 0

# X.loc[X['meter_waiting_fare'] <= 114, 'meter_waiting_fare_outlier'] = 1
# X.loc[X['meter_waiting_fare'] > 114, 'meter_waiting_fare_outlier'] = 0

X['speed'] = X['distance']/X['effective_time']

X['effective_fare'] = X['fare'] - X['meter_waiting_fare']

# X['duration'] = X['duration'].fillna((X['drop_time'] - X['pickup_time']).astype('timedelta64[s]'))
X['Correct_fare'] = 92.33*X['distance']+0.057+X['meter_waiting']*0.057

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)

test_features_df["pickup_time"] = pd.to_datetime(test_features_df["pickup_time"],errors = "coerce")
test_features_df["drop_time"] = pd.to_datetime(test_features_df["drop_time"],errors = "coerce")
test_features_df["distance"] =  distance(test_features_df["pick_lat"],test_features_df["pick_lon"],test_features_df["drop_lat"],test_features_df["drop_lon"])
test_features_df["pickup_time_hour"] = test_features_df["pickup_time"].dt.hour
test_features_df["pickup_time_minute"] = test_features_df["pickup_time"].dt.minute
test_features_df["drop_time_hour"] =test_features_df["drop_time"].dt.hour
test_features_df["drop_time_minute"] =test_features_df["drop_time"].dt.minute
test_features_df["effective_time"] = test_features_df["duration"]-test_features_df["meter_waiting"]
test_features_df["pickup_time_day"] = test_features_df["pickup_time"].dt.day
# test_features_df["pickup_time_month"] = test_features_df["pickup_time"].dt.month
test_features_df["drop_time_day"] = test_features_df["drop_time"].dt.day
# test_features_df["drop_time_month"] = test_features_df["drop_time"].dt.month
# test_features_df["pick_up_year"] = test_features_df["drop_time"].dt.year
# test_features_df["drop_year"] = test_features_df["drop_time"].dt.year
# test_features_df["distance"] =(test_features_df["pick_lat"]-test_features_df["drop_lat"])**2 + (test_features_df["pick_lon"]-test_features_df["drop_lon"])**2

# test_features_df["effective_time"] = (test_features_df["effective_time"] -test_features_df["effective_time"].mean() )/test_features_df["effective_time"].std() 
# test_features_df["effective_fare"] = (test_features_df["effective_fare"] -test_features_df["effective_fare"].mean() )/test_features_df["effective_fare"].std() 
# test_features_df["mean_fare_for_unit_length"] = (test_features_df["mean_fare_for_unit_length"] -test_features_df["mean_fare_for_unit_length"].mean() )/test_features_df["mean_fare_for_unit_length"].std() 
# test_features_df["duration_fare"] = (test_features_df["duration_fare"] -test_features_df["duration_fare"].mean() )/test_features_df["duration_fare"].std()

# test_features_df = test_features_df.drop(columns=["pickup_time","drop_time"],axis=1)
test_features_df.loc[test_features_df['fare'] <= 2000, 'fare_outlier'] = 1
test_features_df.loc[test_features_df['fare'] > 2000, 'fare_outlier'] = 0

test_features_df['meter_waiting_fare_diff'] = test_features_df['meter_waiting_fare'] - test_features_df['meter_waiting']*0.057

test_features_df['fare_mean'] = (test_features_df['fare'] - test_features_df['meter_waiting_fare'])/(test_features_df['duration'] - test_features_df['meter_waiting'])

test_features_df['speed'] = test_features_df['distance']/test_features_df['effective_time']

test_features_df['effective_fare'] = test_features_df['fare'] - test_features_df['meter_waiting_fare']

# test_features_df.loc[test_features_df['additional_fare'] <= 100, 'additional_fare_outlier'] = 1
# test_features_df.loc[test_features_df['additional_fare'] > 100, 'additional_fare_outlier'] = 0
test_features_df['Correct_fare'] = 92.33*test_features_df['distance']+10.5+test_features_df['meter_waiting']*0.057

# test_features_df.loc[test_features_df['meter_waiting'] <= 2000, 'meter_waiting_outlier'] = 1
# test_features_df.loc[test_features_df['meter_waiting'] > 2000, 'meter_waiting_outlier'] = 0

# test_features_df.loc[test_features_df['duration'] <= 6000, 'duration_outlier'] = 1
# test_features_df.loc[test_features_df['duration'] > 6000, 'duration_outlier'] = 0

# test_features_df.loc[test_features_df['meter_waiting_fare'] <= 114, 'meter_waiting_fare_outlier'] = 1
# test_features_df.loc[test_features_df['meter_waiting_fare'] > 114, 'meter_waiting_fare_outlier'] = 0

# test_features_df['speed'] = test_features_df['distance']/test_features_df['effective_time']

categorical_var1 = np.where(test_features_df.dtypes != np.float )[0]

categorical_var1

test_features_df.dtypes

X.dtypes

categorical_var = np.where(X.dtypes != np.float )[0]

categorical_var

eval_dataset = Pool(X_test,y_test)

eval_dataset

"""# Model training"""

model = CatBoostClassifier(iterations=6000,nan_mode='Max')
# model = CatBoostClassifier(eval_metric='F1')

model.fit(X,y,plot=True)

# model.fit(X_train,y_train,eval_set=eval_dataset,verbose=False)

# print(model.get_best_iteration())

prediction = model.predict(test_features_df)

prediction

submission_df = pd.read_csv("sample_submission.csv", 
                            index_col="tripid")

X.head()

np.testing.assert_array_equal(test_features_df.index.values, 
                              submission_df.index.values)

submission_df["prediction"] = prediction[:]

submission_df.head()

submission_df.to_csv('Pro_Ultra_Cosmic_Catestropic_Multi_Higher_dimensional_Gamma_Mission.csv', index=True)

model.get_feature_importance()

X.head()

